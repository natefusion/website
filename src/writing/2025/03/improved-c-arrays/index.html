<!DOCTYPE html>
<html lang="en-US">
    <head>
      <title>NCP Writing: Improved C arrays</title>
      <link rel="stylesheet" href="/style.css">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/png" sizes="32x32" href="/ncp.png">
    </head>
    <body>
      <nav>
  <a href="/">ABOUT</a>
  <a href="/projects">PROJECTS</a>
  <a href="/writing">WRITING</a>
  <a href="/links">LINKS</a>
  <a href="/resume.pdf">RESUME</a>
</nav>
<hr>
<script src="/nav.js"></script>
      <main>
        <h3 class="green">Improved C arrays</h3>
        <hr>
        <i>Some simple macros and functions that make using arrays in C nicer.</i>
        <hr>
        <p>
          I took an operating systems course last semester. In that class my professor assigned a few C programming projects that would be a lot easier if C had builtin dynamic arrays. During that time I had been reading about implementing arenas and dynamic arrays in C,
          
            <label for="sn-1" class="margin-toggle sidenote-number"></label>
            <input type="checkbox" id="sn-1" class="margin-toggle"/>
            <span class="sidenote"><a href="https://nullprogram.com/blog/2023/10/05/">https://nullprogram.com/blog/2023/10/05/</a></span>
            
          so I thought why not make something for myself to make array handling easier for the assignment.
        </p>
        <p>
          I wanted these qualities:
        </p>
        <ul>
          <li>Append elements from arrays</li>
          <li>Works with any data type</li>
          <li>Bundle array lifetimes together</li>
          <li>Bounds checking</li>
        </ul>
        <div class="highlight" style="background: #ffffff"><pre><span></span><span style="color: #888; font-weight: bold">#define Vec_define(T, name) \</span>
<span style="color: #888; font-weight: bold">    typedef struct { T *data; int len; int cap; } name</span>
</pre></div>

        <p>
          I started with a macro to make a new array container for the specified data type. This is basically the same as <code class='highlightraw'>std::vector&lt;T&gt;</code>.
        </p>
        <div class="highlight" style="background: #ffffff"><pre><span></span><span style="color: #888; font-weight: bold">#define is_pointer(p)  (__builtin_classify_type(p) == 5)</span>
<span style="color: #888; font-weight: bold">#define maybe_ref(x) __builtin_choose_expr(is_pointer((x)), (x), &amp;(x))</span>

<span style="color: #888; font-weight: bold">#define len(x) (maybe_ref((x))-&gt;len)</span>
<span style="color: #888; font-weight: bold">#define cap(x) (maybe_ref((x))-&gt;cap)</span>
<span style="color: #888; font-weight: bold">#define data(x) (maybe_ref((x))-&gt;data)</span>
</pre></div>

        <p>
          These are special macros to access each of the members regardless of whether it is a pointer or not. The builtin gcc function <code class='highlightraw'>__builtin_classify_type</code> return 5 when the variable is a some pointer. The builtin <code class='highlightraw'>__builtin_choose_expr</code> is the same as the ternary operator, but it won't evaluate the false branch. I can use these two builtins to check if the variable is a pointer, which in that case do nothing, and return a reference to the variable if it isn't a pointer. Then I can always use the <code>-></code> operator on the variable. This is mildly useful.
        </p>

        <div class="highlight" style="background: #ffffff"><pre><span></span><span style="color: #888; font-weight: bold">#define at(v, index) \</span>
<span style="color: #888; font-weight: bold">    data((v))[(void)assert((index) &lt; len((v))), (index)]</span>
</pre></div>

        <p>
          This macro mimics <code class='highlightraw'>std::vector::at</code>. It indexes the array and will perform bounds checking. A benefit of using the builtin assert is that it can be disabled by passing <code class='highlightraw'>-DNDEBUG</code> to the compiler.
        </p>
        <div class="highlight" style="background: #ffffff"><pre><span></span>Vec_define(<span style="font-weight: bold">void</span>*, Arena);
             
<span style="font-weight: bold">void</span> <span style="color: #666; font-weight: bold; font-style: italic">Arena_append</span>(Arena *arena, <span style="font-weight: bold">void</span> *p) {
    <span style="font-weight: bold">if</span> (len(arena) &gt;= cap(arena)) {
        cap(arena) = cap(arena) == 0 ? 4 : cap(arena) * 2;
        data(arena) = realloc(data(arena)
                             ,cap(arena) * <span style="font-weight: bold">sizeof</span>(<span style="font-weight: bold">void</span>*));
    }
    len(arena) += 1;
    last(arena) = p;
}

<span style="font-weight: bold">void</span> *<span style="color: #666; font-weight: bold; font-style: italic">Arena_realloc</span>(Arena *arena, <span style="font-weight: bold">void</span> *p, <span style="font-weight: bold">int</span> n, <span style="font-weight: bold">int</span> size) {
    <span style="font-weight: bold">if</span> (p != <span style="font-weight: bold; font-style: italic">NULL</span>) {
        <span style="font-weight: bold">for</span> (<span style="font-weight: bold">int</span> i = 0; i &lt; len(arena); ++i) {
            <span style="font-weight: bold">if</span> (at(arena, i) == p) {
                <span style="font-weight: bold">void</span> *new_p = realloc(p, n * size);
                at(arena, i) = new_p;
                <span style="font-weight: bold">return</span> new_p;
            }
        }
        fprintf(stderr, <span style="color: #666; font-style: italic">&quot;Don&#39;t do that, pls\n&quot;</span>);
        exit(1);
    } <span style="font-weight: bold">else</span> {
        <span style="font-weight: bold">void</span> *new_p = calloc(n, size);
        Arena_append(arena, new_p);
        <span style="font-weight: bold">return</span> new_p;
    }
}

<span style="font-weight: bold">void</span> <span style="color: #666; font-weight: bold; font-style: italic">Arena_deinit</span>(Arena *arena) {
    <span style="font-weight: bold">for</span> (<span style="font-weight: bold">int</span> i = 0; i &lt; len(arena); ++i) free(at(arena, i));
    free(data(arena));
}
</pre></div>

            <p>
              To handle array lifetimes, I created these functions. I called it an <code class='highlightraw'>Arena</code>, because I was reading about arenas when I wrote this, but really, it's a garbage collector. <code class='highlightraw'>Arena</code> is just an array of void pointers, as a way to track the lifetimes of my arrays. To put a new array into the <code class='highlightraw'>Arena</code>, just pass the pointer to your array to with your <code class='highlightraw'>Arena</code> instance to <code class='highlightraw'>Arena_append</code>. <code class='highlightraw'>Arena_realloc</code> is just a wrapper around regular <code class='highlightraw'>realloc</code>. It will search through the <code class='highlightraw'>Arena</code> all call <code class='highlightraw'>realloc</code> on the matching pointer. <code class='highlightraw'>Arena_deinit</code> will simply free every pointer in <code class='highlightraw'>Arena</code> and and finally itself.
            </p>
            <div class="highlight" style="background: #ffffff"><pre><span></span><span style="color: #888; font-weight: bold">#define grow(vec, arena)                               \</span>
<span style="color: #888; font-weight: bold">    (cap(vec) = (cap(vec) == 0 ? 4 : cap(vec) * 2),    \</span>
<span style="color: #888; font-weight: bold">     data(vec) = Arena_realloc(maybe_ref(arena),       \</span>
<span style="color: #888; font-weight: bold">                               data(vec),              \</span>
<span style="color: #888; font-weight: bold">                               cap(vec),               \</span>
<span style="color: #888; font-weight: bold">                               sizeof(*data(vec))))</span>

<span style="color: #888; font-weight: bold">#define append(vec, arena)                      \</span>
<span style="color: #888; font-weight: bold">    (len((vec)) &gt;= cap((vec))                   \</span>
<span style="color: #888; font-weight: bold">     ? (grow((vec), (arena)) + len((vec))++)    \</span>
<span style="color: #888; font-weight: bold">     : (data((vec)) + len((vec))++))</span>
</pre></div>

            <p>
              These are two helper macros to make appending elements easily. They need to be macros because C doesn't have polymorphism, this is the closest I'm going to get. <code class='highlightraw'>append</code> will return a pointer to the last element so it would be used as an lvalue. This works even when the array and arena structs are zeroed.
            </p>
            <div class="highlight" style="background: #ffffff"><pre><span></span>Vec_define(<span style="font-weight: bold">int</span>, Vec_int);
                 
<span style="font-weight: bold">int</span> <span style="color: #666; font-weight: bold; font-style: italic">main</span>(<span style="font-weight: bold">void</span>) {
    Vec_int array = {0};
    Arena arena = {0};
    *append(array, arena) = 1;
    assert(at(array, 0) == 1);
    Arena_deinit(&amp;arena);
}
</pre></div>

      </main>
    </body>
</html>
